title: 2021-03-31
author: 98hyun
published: 2021-03-31
description: 정규표현식과 NLP에 대해서 간단하게 공부했다. 4월에 bert와 fasttext를 소개할 생각이다. python문법, latex, html symbols와 emoji에 대해 간단히 언급한다. matplotlib 그리고 matplotlib에 글과 그림을 한번에 표현하는 방법을 소개한다. 이번 3월의 공부는 통계를 많이 공부했다. 맥북도 공부했다. 
tags: [데이터분석, 통계, 시각화]

<span style="border:solid 1px black;background-color:#2e3f59"> </span> &nbsp; 정규표현식과 NLP  

규칙과 함수가 있다면 빠르게 접근 가능하다.  

    :::python
    import re 

    s='https://98hyun.github.io/ here'
    p=re.compile(r'https\S+')
    print(p.sub(r'',s))
    # _here

    # 자주 사용하는 축약어. 거의 escape와 [] 이거 많이 사용한다.  

<img src="https://i.stack.imgur.com/KiaKd.png" width=700 height=600>

<span style="border:solid 1px black;background-color:#2e3f59"> </span> &nbsp; latex와 python

빼놓을 수 없다. 특히, matplotlib 와 연계로. [참고](https://ko.wikipedia.org/wiki/%EC%9C%84%ED%82%A4%EB%B0%B1%EA%B3%BC:TeX_%EB%AC%B8%EB%B2%95)  

    :::python 
    import numpy as np
    import matplotlib.pyplot as plt

    # 실행하면 
    x=np.linspace(-10,10,100)
    y=np.tanh(x)

    plt.figure()
    plt.plot(x,y)
    plt.xlabel('$x$')
    plt.ylabel('$\\tanh(x)$')
    plt.title('쌍곡탄젠트함수',fontproperties=fontprop)
    plt.suptitle(r'정의역 : 모든실수, 치역 : [-1,1]',fontproperties=fontprop,x=0.34,y=0.8)
    plt.grid();

![](https://ifh.cc/g/ybX98u.png)   

    :::python 
    # 이거는 그냥 jupyter 환경에서 실행하면 latex형태로 표현한다.  
    from sympy import *

    x,u=symbols('x u')
    u=sin(x)
    
    diff(u,x)
    # 참고해서 그린 그림. 

![](https://ifh.cc/g/ho96TT.png)
        
<span style="border:solid 1px black;background-color:#2e3f59"> </span> &nbsp; 파이썬 스킬.

공부하면서 배운 파이썬 스킬.  

    :::python 
    # 블록체인 내용 중. 
    # class내에 구현된 hash함수. snip
    # 작용하는것은 class안에서도 self.hash(last_block)로 접근 가능하다.  

    @staticmethod
    def hash(block):
        block_string = json.dumps(block, sort_keys=True).encode()
        return hashlib.sha256(block_string).hexdigest()

    # 그 외로 classmethod가 있는데. 참고. https://dojang.io/mod/page/view.php?id=2380 
    # cls 인자를 꼭 받는다. 굳이 필요있나 싶다.  

    # cls로 class 속성에 접근할 수 있다. 
    @classmethod
    def print_count(cls):
        print('{0}명 생성되었습니다.'.format(cls.count))

    # 다른 문법 
    # 출력 : 2 
    print(False or 2)

    # 간혹 데이터베이스 만질 때나 github에 push 할때 secret key 같은거. 저장할 때 팁. 
    # config.py 파일을 하나 만들고 안에 변수로 작성. 
    # app.py 같은 flask 안에서. https://mingrammer.com/ways-to-manage-the-configuration-in-python/  
    import config

    print(config.PASSWORD) # 123456 이런식으로 접근. 

<span style="border:solid 1px black;background-color:#2e3f59"> </span> &nbsp; [통계 개념 참고](https://chukycheese.github.io/statistics/twenty-nine-statistical-concepts-explained-in-simple-english/)  

* modality 

modality
mode는 최빈값 즉, modality는 최빈값이 될수있는 이라고 해석하면 될것같다. 

unimodal - 하나
bimodal - 둘
multimodal - 셋 이상.

<details><summary>code</summary>
<blockquote>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns 

f, ax = plt.subplots(nrows=1, ncols=3, figsize=(18, 4))

# Unimodal
sns.distplot(np.random.normal(10, 5, 10000), ax=ax[0], hist=False, color='blue')
ax[0].set_title('Unimodal', fontsize=14)
ax[0].set_yticklabels([])
ax[0].set_xticklabels([])

# Bimodal
sample_bimodal = pd.DataFrame({'feature1' : np.random.normal(10, 5, 10000),
                   'feature2' : np.random.normal(40, 10, 10000),
                   'feature3' : np.random.randint(0, 2, 10000),
                  })

sample_bimodal['combined'] = sample_bimodal.apply(lambda x: x.feature1 if (x.feature3 == 0 ) else x.feature2, axis=1)

sns.distplot(sample_bimodal['combined'].values, ax=ax[1], color='blue', hist=False)

ax2 = ax[1].twinx()  # instantiate a second axes that shares the same x-axis

sns.distplot(sample_bimodal.feature1, ax=ax2, color='blue', kde_kws={'linestyle':'--'}, hist=False)
sns.distplot((sample_bimodal.feature2), ax=ax2, color='blue', kde_kws={'linestyle':'--'}, hist=False)

f.tight_layout()  # otherwise the right y-label is slightly clipped

ax[1].set_title('Bimodal', fontsize=14)
ax[1].set_yticklabels([])
ax[1].set_xticklabels([])
ax2.set_yticklabels([])


# Multimodal
sample_multi = pd.DataFrame({'feature1' : np.random.normal(10, 5, 10000),
                   'feature2' : np.random.normal(40, 10, 10000),
                   'feature3' : np.random.randint(0, 3, 10000),
                               'feature4' : np.random.normal(80, 4, 10000),
                  })

sample_multi['combined'] = sample_multi.apply(lambda x: x.feature1 if (x.feature3 == 0 ) else (x.feature2 if x.feature3 == 1 else x.feature4), axis=1 )

sns.distplot(sample_multi['combined'].values, ax=ax[2], color='blue', hist=False)

ax3 = ax[2].twinx()  # instantiate a second axes that shares the same x-axis

sns.distplot(sample_multi.feature1, ax=ax3, color='blue', kde_kws={'linestyle':'--'}, hist=False)
sns.distplot((sample_multi.feature2), ax=ax3, color='blue', kde_kws={'linestyle':'--'}, hist=False)
sns.distplot((sample_multi.feature4), ax=ax3, color='blue', kde_kws={'linestyle':'--'}, hist=False)

f.tight_layout()  # otherwise the right y-label is slightly clipped

ax[2].set_title('Multimodal', fontsize=14)
ax[2].set_yticklabels([])
ax[2].set_xticklabels([])
ax3.set_yticklabels([])

plt.show()</code></pre>
</blockquote>
</details>

<img src="https://ifh.cc/g/rcenzU.png" width=700 height=200>

* qqplot 

normality test. 오른쪽이 qqplot 왼쪽은 단순 분포 확인.

<details><summary>code</summary>
<blockquote></blockquote>
<pre><code>
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import kstest

# 정규분포 
temp1=np.random.normal(5,0.01,size=1000)

fig,ax=plt.subplots(1,2,figsize=(10,4),dpi=200)

sns.kdeplot(temp1,ax=ax[0]);
res=probplot(temp1,plot=ax[1])
kstest(temp1,'norm')

# 비정규 분포 - 어떤파일을 임의로 한것. 
scaler=StandardScaler()

temp1=temp['평당가격'].values

fig,ax=plt.subplots(1,2,figsize=(10,4),dpi=200)

sns.kdeplot(temp1,ax=ax[0]);
res=probplot(temp1,plot=ax[1])
temp1=scaler.fit_transform(temp1.reshape(-1,1))
kstest(temp1,'norm')

</code></pre>
</details>

<img src="https://ifh.cc/g/WdvAez.png" width=700 height=400>
<img src="https://ifh.cc/g/MbA5Uy.png" width=700 height=400>

* normality test에 대해서  

표본수가 2000개 이하면 shapiro test를 사용한다. 반대라면 Kolmogorov를 사용한다.   

H0 : 귀무가설. 귀무가설이 틀릴확률을 유의수준 0.05라고 정했을 때, p-value(이상값)를 구했는데 이상값 나올 확률보다 귀무가설이 틀릴확률이 높으면 귀무가설을 기각한다. 보통 기존을 유지하는것을 귀무가설. 변화를 지켜보는 쪽을 대립가설(H1)을 한다.     

그래서 분석에 필요한 여러 분석을 거친뒤에 모델을 정하는데 가장 간단한 선형회귀도 4가지 가정이 있다. 

* 선형 회귀 

(1) 선형성 : 독립변수와 종속변수의 scatter plot을 그려 선형성을 파악.  
(2) 독립성 : 독립변수들간에 상관관계가 없는지. 다중회귀에서 쓰인다.  
(3) 등분산성 : 종속변수의 분산이 같은지. 주체는 잔차. 만약 골고루 퍼져있지않다면 연결하기 위한 매개변수가 필요하다.  
(4) 정규성 : 정규분포를 띄는지.   

그래서 보통 선형회귀가 맞는데 찾기가 어렵다. 그래서 비모수 통계 모델을 많이 사용한다.  

* 비모수 통계 모델 

k-최근접 알고리즘, randomforest, 의사결정트리 같은 모델들이 있다.  

약간, semi-모수 통계 모델이라고 하는 Support Vector Machine, 인공신경망이 있다.  

변수의 확률 분포를 신경쓰는지 여부에 따라 구분했다. [참고](https://brunch.co.kr/@seoungbumkim/7)

* 모델의 정규화

나중에 인공지능 파트에서도 layer normalization과 batch normalization 같은 정규화 기법을 볼 수 있는데, tabular 에서도 볼 수 있다. 

normalization

    :::python 
    # 기본 parameter로 되서 다른건 안만지면 된다.
    # 참고사이트 https://www.kaggle.com/raphael2711/customer-segmentation-with-gmm-clustering
    from sklearn.preprocessing import StandardScaler,normalize

    scaler=StandardScaler()

    X_std=scaler.fit_transform(X) # 표준화 -> 각 열에 대해서 독립
    X=normalize(X_std) # 정규화 -> 각 행에 대해서 독립

* feature engineering 

피처 공학은 모델 잘 설명할 수 있는 features를 만드는게 목적이다.   
그 중 범주형 변수들을 다루는 좋은 라이브러리가 있다. 
[categorical 변수 다루기 참고](https://www.kaggle.com/subinium/11-categorical-encoders-and-benchmark) 

    :::python
    from category_encoders import LeaveOneOutEncoder

    loo = LeaveOneOutEncoder()
    # train 데이터의 categorical columns들과 일대일 대응인 target들을 맞춰줍니다. 
    # leave one out encoder은 현재 target을 제외한 타겟들의 평균을 계산하여 feature를 만듭니다. 
    loo.fit(train_df[cat_cols], train_df['target'])  
    train_df[new_feature] = loo.transform(train_df[cat_cols])

<span style="border:solid 1px black;background-color:#2e3f59"> </span> &nbsp; 시각화  

* Pseudo-code (의사코드) 

이런식으로 알고리즘임을 알리고, 알기 쉽게 입력변수와 출력 변수, 과정을 알기 쉽게 한다.  

<pre>
Algorithm array_sum
input : array
output : sum of array elements

sum <- 0
for all elements in array do
    sum <- sum + each element

return sum
</pre>

* matplotlib 

kaggle에는 세계의 많은 분들이 저마다의 재밌고 유용한 스킬들을 보여준다.  
참고 했던 사이트다. [참고](https://www.kaggle.com/joshuaswords/data-visualization-clustering-mall-data) 

    :::python
    import matplotlib.pyplot as plt
    
    fig,ax=plt.subplots(1,1,figsize=(15,10),dpi=200) # 즐겨하는 약속같은 코드다.  
    ax.grid(axis='y',linestyle='-',alpha=0.4)  # y grid만 그린다. 

    # fig는 큰 틀. ax는 그 안에 canvas라고 생각한다. 
    # 아래 코드는 fig 안에 line을 그려 칸을 나누는것이다. fig는 거의 무한하다고 생각하면 된다. 
    # 그 안에 ax로 조절을 하는건데 아래 코드와 같이 쓰인 fig.text 가 있다. 

    import matplotlib.lines as lines
    l1 = lines.Line2D([1.05, 1.05], [0, 1.05], transform=fig.transFigure, figure=fig,color='black',lw=0.2)
    fig.lines.extend([l1])

    fig.text(1.185, 0.715, '''
    The two most frequent age bands are 20-30 
    and 30-40. In the early stages of our 
    exploratory analysis, we can already start
    to think about who our most important customers
    are and, importantly, how we might tailor our
    marketing activities or promotional offers based
    on customer segments.
    ''', fontsize=12, fontweight='light', fontfamily='serif')

* html symbols

html 공부중 알게 됐다. [참고](https://www.rapidtables.com/web/html/html-codes.html)   
 `&#60;` 는 < 를 의미한다. 

* emojis 

github 혹은 kaggle 또는 글에 🔥 이렇게 쓸 수 있는 emoji 들이다. [참고](https://emojipedia.org/)  

<span style="border:solid 1px black;background-color:#2e3f59"> </span> &nbsp; macOS 

맥북도 공부한다.  

* mac : 단축키 

맥북은 command키로 쉽게 조작이 가능하다.   
그 중 괜찮은 스킬이다.  

<pre>
command+space : spotlight 검색. (어플 실행 시 자주사용)
ctrl+command+f : 전체화면. (전체화면 후 터치패드 세손가락으로 왔다갔다가 제일 좋다.)
command+shift+l : 읽기목록 옆에 키우기. 아래 코드와 연계다. 
command+shift+d : 현재 페이지 저장. 
command+l : 주소 검색 (구글로 설정 하면 검색이 쉬워진다.)
</pre>

* vim 
 
[공부 영상](https://www.youtube.com/watch?v=g-XsXEsd6xA&t=256s)

<pre>

</pre>


